{
    "collab_server" : "",
    "contents" : "#######################################################\n#TODO:\n# Remember: when updating on server, use library(Cairo)\n#######################################################\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(rms)\nlibrary(data.table)\n#library(Cairo) # for better graphics on Linux servers\n#options(shiny.usecairo= TRUE)\n\n#  colors, from http://www.sron.nl/~pault/\n# these are slightly less cb-friendly, but optimized for screen\ns.red    <- \"#EE3333\"\ns.orange <- \"#EE7722\"\ns.yellow <- \"#FFEE33\"\ns.green  <- \"#66AA55\"\ns.teal   <- \"#11AA99\"\ns.dkblue <- \"#3366AA\"\ns.magenta<- \"#992288\"\ns.mustard<- \"#CCCC55\"\nmyColorScale <- c(\n    s.orange,\n    s.dkblue,\n    s.magenta,\n    s.teal  ,\n    s.red    ,\n    s.yellow,\n    s.green ,\n    s.mustard\n)    \n\n# number of decimal places to use w/ propensity scores\npsdig <- 2\n\n# alpha for graphs\nalpha1 <- 0.7\n\n\n# Allow upload of bigger files\n# from http://stackoverflow.com/questions/18037737/how-to-change-maximum-upload-size-exceeded-restriction-in-shiny-and-save-user\n# The first number is the number of MB\noptions(shiny.maxRequestSize=30*1024^2)\n\n\nshinyServer(function(input, output, session) {\n    ############################################################\n    ############################################################\n    ## Datasets \n    \n    inFile <- reactive({\n        if (input$useExampleData == 1) return(NULL)\n        input$datafile\n    })\n    \n    output$chooseDatafile <- renderUI({\n        if (input$useExampleData == 1) return(NULL)\n        fileInput('datafile', \n            label= 'Upload file (.csv or .rds only):',\n            accept= NULL\n            # as far as I can tell, 'accept' does not actually limit anything\n            #accept= c(\n            #    'text/csv', \n            #    'text/comma-separated-values,text/plain', \n            #    '.csv'#,\n            #    #'application/octet-stream'\n            #    )\n        )\n    })\n    dset.orig <- reactive({\n        # File input from example on shiny website\n        # input$datafile will be NULL initially. \n        # After the user selects\n        # and uploads a file, it will be a data frame with 'name',\n        # 'size', 'type', and 'datapath' columns. The 'datapath'\n        # column will contain the local filenames where the data can\n        # be found.\n        \n        if (input$useExampleData == 0 & is.null(inFile())) return(NULL)\n    \n        if (input$useExampleData == 1) {\n            nt <- 300\n            nc <- 700\n            group <- rep(c(\"Exposed\", \"Unexposed\"), times= c(nt, nc))\n            height_ft <- c(rnorm(nt, 5.4, .3), rnorm(nc, 5.6, .2))\n            gender <- c(rbinom(nt, 1, .66), rbinom(nc, 1, .5))\n            gender[gender == 0] <- \"Male\"\n            gender[gender == 1] <- \"Female\"\n            age <- c(rnorm(nt, 45, 5), rnorm(nc, 50, 10))\n            systolic_bp <- c(rnorm(nt, 115, 5), rnorm(nc, 110, 7)) \n            mydat <- data.table(group, height_ft, gender, age, systolic_bp)\n        }  else if (!is.null(inFile())) {\n            if (grepl(\"\\\\.csv\\\\>\", inFile()$name)) {\n                mydat <- fread(inFile()$datapath,\n                    sep= \",\",\n                    header= TRUE,\n                    data.table= TRUE\n                )\n            } else if (grepl(\"\\\\.rds\\\\>\", inFile()$name)){\n                # todo: add error handling\n                mydat <- as.data.table(readRDS(inFile()$datapath))\n            }    \n        }\n        mydat\n    })\n    \n    idvarName <- reactive({\n        # The name produced by this function will be used as\n        # the name of the id var\n        if(is.null(dset.orig())) return (NULL)\n        \n        proposedName <- \"MY__ID\"\n        while(proposedName %in% names(dset.orig())) {\n            proposedName <- paste0(proposedName, \"_NEW\")    \n        }    \n        proposedName\n    })    \n    corevarnames <- reactive({\n        # Vector of core variable names for determining missingness.\n        if (is.null(varnamesFromModel()) & is.null(varsToView())) return(NULL)\n\n        unique(c(varsToView(), \n            # groupvarname() is part of varnamesFromModel(),\n            # but this is here in case model not specified yet\n            groupvarname(), varnamesFromModel()))\n    })\n    output$isnaCopyText <- renderText(paste(corevarnames(), collapse= \", \"))\n    \n    nonMissingIDs <- reactive({\n        if (is.null(corevarnames())) return(NULL)\n        \n        # todo: offer option to impute & add vars\n        na.omit(dset.orig()[, c(corevarnames(), idvarName()), with= FALSE])[[idvarName()]]\n    })\n    \n    observe({\n        # Add a factor version of the treatment indicator, for plotting\n        if (!is.null(groupvarFactorName())){\n            if (groupvarname() %in% names(dset.orig())) {\n                print(\"A\")\n                if (!is.factor(dset.orig()[[groupvarname()]])) {\n                    print(\"A2\")\n                    dset.orig()[, groupvarFactorName() := factor(dset.orig()[[groupvarname()]])]\n                }\n                print(\"B\")\n            }\n        }\n    })\n\n    observe({\n        # Add an ID variable so we can match obsns w/ the PS dataset\n        if (!is.null(idvarName())) { \n            if (!(idvarName() %in% names(dset.orig()))) {\n                print(\"C\")\n                dset.orig()[, idvarName() := 1:nrow(dset.orig())]\n                print(\"D\")\n                setkeyv(dset.orig(), idvarName())\n            }\n        }\n    })\n    \n    dset.psgraphs <- reactive({\n        # This dataset is used for making the PS plots.\n        if (is.null(logitPS())) return(NULL)\n        \n        # todo: do this all using data.table\n        dat1 <- data.frame(\n            id       = unlist(dset.orig()[nonMissingIDs(), idvarName(), with= FALSE]),\n            group    = unlist(dset.orig()[nonMissingIDs(), groupvarFactorName(), with= FALSE])\n        )\n        dat2 <- data.frame(\n            id       = PSIDs(),\n            logit.ps = logitPS(), \n            ps       = PS()\n        )\n        dat <- merge(dat1, dat2, by= \"id\")  # keep only subjects with values in both \n        names(dat)[names(dat) == \"id\"] <- idvarName()\n        dat <- as.data.table(dat)  \n        setkeyv(dat, idvarName())\n        dat\n    })    \n\n    observe({\n        # for bar plots, need to turn discrete numeric vars into factors\n        if (!is.null(varsToView())) {\n            for (varname in varsToView()) {\n                if (is.numeric(dset.orig()[[varname]]) & \n                    length(unique(dset.orig()[[varname]])) < input$numCont) {\n                    print(\"E\")\n                    # todo: make sure levels are transferring right\n                    if (!is.factor(dset.orig()[[varname]])) {\n                        print(\"E2\")\n                        dset.orig()[, eval(varname) := factor(dset.orig()[[varname]])]\n                        print(\"E3\")\n                    }\n                    print(\"F\")\n                }\n            }\n        }    \n    })    \n    \n    xgraphs.ids <- reactive({\n        # IDs for making the covariate plots.\n        if (is.null(nonMissingIDs())) return(NULL)\n\n        intersect(nonMissingIDs(), idsToKeepAfterPruning())\n    })    \n    \n    \n    \n    ############################################################\n    ############################################################\n    ## Variable selection, etc.\n    \n    varnames.orig <- reactive({\n        names(dset.orig())  \n    })\n        \n    output$dataDimText <- renderText({\n        if (is.null(dset.orig())) return(NULL)\n        paste0(\"The dataset has \", ncol(dset.orig()), \n            \" columns and \", nrow(dset.orig()), \" rows.\")\n    })\n\n    output$chooseGroup <- renderUI({\n        if (is.null(dset.orig())) return(NULL)\n        selectizeInput('treatmentVarName', \n            #'Which variable is the treatment indicator?', \n            label= NULL, \n            choices= varnames.orig()[sapply(dset.orig(), \n                function(vec) length(unique(vec)) == 2)], \n            selected= NULL,\n            multiple= FALSE\n            )\n    })\n    \n    groupvarname <- reactive({\n        input$treatmentVarName\n    })\n    \n    output$groupLevelText <- renderText({\n        if (is.null(groupvarname())) return(NULL)\n        \n        # the as.character lets this print right if var is already a factor\n        as.character(sort(unique(dset.orig()[[groupvarname()]])))\n    })\n\n    groupvarFactorName <- reactive({\n        # The name produced by this function will be used as\n        # the name of the treatment group var \n        if (is.null(dset.orig())) return(NULL)\n        if (is.null(groupvarname())) return(NULL)\n        \n        if (is.factor(dset.orig()[[groupvarname()]])) {\n            return(groupvarname())    \n        }    \n        proposedName <- paste0(groupvarname(), '.factor')\n        while(proposedName %in% names(dset.orig())) {\n            proposedName <- paste0(proposedName, \"NEW\")    \n        }    \n        proposedName\n    })    \n\n\n    possVarsToRestrict <- reactive({\n        if (is.null(groupvarname())) return(NULL)\n        # We don't want to allow restriction of the treatment var \n        setdiff(varnames.orig(), \n            c(groupvarname(), groupvarFactorName(), idvarName()))  \n    })    \n    \n    output$chooseVarsToRestrict <- renderUI({\n        selectizeInput('varsToRestrict', \n            NULL, \n            choices= possVarsToRestrict(), \n            selected= if (is.null(varnamesFromModel())) NULL else \n                setdiff(varnamesFromModel(), groupvarname()),\n            multiple= TRUE\n        )\n    })\n \n    varsToViewText <- reactive({\n        input$varsToRestrict\n    })\n    \n    varsToView <- reactive({\n        #dependencies\n        if (input$selVarsButton == 0) return(NULL)            \n\n        isolate(varsToViewText())\n    })\n    \n    selVarsNotChecked <- reactive({\n        if (input$selVarsButton == 0 | is.null(varsToViewText()) \n            | is.null(varsToView()) ) return (TRUE)\n\n        if(!identical(varsToViewText(), varsToView())) TRUE else FALSE\n    })\n\n    output$selVarsNeedCheckingText <- renderText({\n        if (selVarsNotChecked()) {\n            \"Remember to click the button when you're done!\"\n        } else NULL   \n    })\n\n\n    numvarsToView <- reactive({\n        length(varsToView())    \n    })    \n    \n    output$dataNonmissingDimText <- renderText({\n        if (is.null(nonMissingIDs())) return(NULL)\n        paste0(\"After removal of rows with missing values for the variables selected for the PS and/or for viewing, \",\n            \"the dataset has \", length(nonMissingIDs()), \" rows.\")\n    })\n    \n    output$novarsToViewText <- renderText({\n        if (is.null(varsToView())) {\n            \"To select variables, please return to the Specify tab.\"\n        } else NULL\n    })\n\n    \n\n    ############################################################\n    ############################################################\n    ## Propensity score calculation\n    output$getFormula <- renderUI({\n        if (is.null(dset.orig()) | is.null(groupvarname())) return(NULL)\n        textInput('formulaRHS', \n            label= paste0(groupvarname(), ' ~ '), \n            value= ' '\n        )\n    })\n\n    formRHS <- reactive({\n        # Do nothing if button has never been clicked or if no dset\n        # Dependencies\n        if (input$psButton == 0 | is.null(dset.orig())) return(NULL) \n        \n        isolate(input$formulaRHS)\n    })\n    \n    stringFormula <- reactive({\n        paste0(groupvarname(), ' ~ ', formRHS())\n    })    \n    \n    \n    psForm <- reactive({\n        tryCatch(as.formula(stringFormula()),\n            error= function(e) {return(NULL)})\n    })    \n \n    output$noPSText <- renderText({\n        if (is.null(psForm())) {\n            \"To specify a PS model, please return to the Specify tab.\"\n        } else NULL\n    })\n\n    output$psHelpText <- renderText({\n        \"    age + gender\"\n    })\n    \n    psNotChecked <- reactive({\n        if (input$psButton == 0 |\n            paste0(groupvarname(), ' ~ ', input$formulaRHS) != stringFormula()) TRUE else FALSE\n    })\n\n    output$psFormulaProblemText <- renderText({\n        # dependencies\n        if (psNotChecked()) return(\" \")\n\n        if (is.null(psForm())) {\n            \"That is not a usable RHS. Please try again.\"   \n        } else {\n            \"Passed\"   \n        }\n    })\n\n    PSIDs <- reactive({\n        # dependencies\n        if (input$PSCalcUpdateButton == 0) return(nonMissingIDs()) \n        input$psButton # in case model changed after pruning\n            \n        intersect(nonMissingIDs(), isolate(idsToKeepAfterPruning()))\n    })\n\n    varnamesFromModel <- reactive({\n        if (is.null(psForm())) return(NULL)\n        \n        allvars <- all.vars(psForm())\n        if (all(allvars %in% names(dset.orig()))) allvars else NULL\n    })    \n\n    output$psVarsProblemText <- renderText({\n        # dependencies\n        if (psNotChecked()) return(\" \")\n\n        if (is.null(isolate(varnamesFromModel()))) {\n            \"The formula uses variables that are not in the dataset. Please try again.\"   \n        } else {\n            \"Passed\"\n        }    \n    })\n\n    output$psNeedsCheckingText <- renderText({\n        if (psNotChecked()) {\n            \"Remember to click the button when you're done!\"\n        } else NULL   \n    })\n\n    lrmfit <- reactive({\n        if (is.null(psForm()) | is.null(varnamesFromModel())) return(NULL)\n        \n        tryCatch({lrm(psForm(), \n            data= dset.orig()[PSIDs()])},\n            error= function(e) {return(NULL)})\n    })\n\n    output$psCopyText <- renderText({\n        # dependencies\n        if(is.null(lrmfit())) return(NULL)\n    \n        isolate(stringFormula())\n    })\n\n    output$psFitProblemTextPrePruning <- renderText({\n        # dependencies\n        if (psNotChecked() | is.null(varsToView())) return(\" \")\n\n        if (is.null(isolate(lrmfit()))) {\n            \"The propensity score formula can't be fit using the current dataset. Please modify the model and/or the variables selected for viewing.\"   \n        } else {\n            \"PS model successfully fit.\"\n        }    \n    })\n    output$psFitProblemTextPostPruning <- renderText({\n        # dependencies\n        if (psNotChecked() | is.null(varsToView()) | \n            input$PSCalcUpdateButton  == 0) return (NULL)\n\n        if (is.null(isolate(lrmfit()))) {\n            \"The propensity score formula can't be fit using the current dataset. Please modify the model, the variables selected for viewing, and/or the pruning criteria.\"   \n        } else {\n            NULL\n        }    \n    })\n\n    logitPS <- reactive({\n        if (is.null(lrmfit())) return(NULL)\n        \n        lrmfit()$linear.predictors\n    })\n\n    PS <- reactive({\n        if (is.null(logitPS())) return(NULL)\n        \n        exp(logitPS()) / (1 + exp(logitPS()))\n    })\n    \n    \n    ############################################################\n    ############################################################\n    ## Reactive text, etc. for PS graphs\n    \n    useLogit <- reactive({\n        !(input$useProbScale)\n    })\n    \n    psbrushmin <- reactive({\n        if (is.null(dset.psgraphs()) |\n            identical(buttonvalues$lastActionRug, 'choosePlot')) return(NULL)\n        if (useLogit()) input$logitpsPlot_brush$xmin else input$psPlot_brush$xmin\n    })\n    \n    psbrushmax <- reactive({\n        if (is.null(dset.psgraphs()) |\n            identical(buttonvalues$lastActionRug, 'choosePlot')) return(NULL)\n        if (useLogit()) input$logitpsPlot_brush$xmax else input$psPlot_brush$xmax\n    })\n    \n    scorename <- reactive({\n        ifelse(useLogit(), \"logit.ps\", \"ps\")\n    })\n    idsForRug <- reactive({\n        if (is.null(dset.psgraphs())) return(NULL)\n        \n        # todo: fix syntax (do all as data.table)\n        #ids <- dset.psgraphs()[round(eval(scorename()), psdig) < psbrushmin() |\n        #    round(eval(scorename()), psdig) > psbrushmax(), eval(idvarName())]\n        outside <- round(dset.psgraphs()[[scorename()]], psdig) < psbrushmin() |\n            round(dset.psgraphs()[[scorename()]], psdig) > psbrushmax()\n        ids <- as.data.table(as.data.frame(dset.psgraphs())[outside, ])[[idvarName()]]\n    })  \n    \n\n    ############################################################\n    ############################################################\n    ## Reactive text related to covariate graphs\n        \n    varIsContinuous <- reactive({\n        if (is.null(varsToView())) return(NULL)\n        \n        myvec <- rep(FALSE, numvarsToView())\n        \n        for(i in 1:numvarsToView()) {\n            varname <- varsToView()[i]\n            \n            if (is.numeric(dset.orig()[[varname]]) & \n                length(unique(dset.orig()[[varname]])) >= \n                input$numCont) myvec[i] <- TRUE\n        }\n        myvec\n    })    \n\n    # number of decimal places to use w/ covariate graphs\n    xdig <- reactive({\n        input$xDigits\n    })\n\n    # from http://stackoverflow.com/questions/18816666/shiny-change-data-input-of-buttons\n    # Create a reactiveValues object, to let us use settable reactive values\n    buttonvalues <- reactiveValues()\n    # To start out, lastActionX == NULL, meaning nothing clicked yet\n    buttonvalues$lastActionX <- NULL\n    # An observe block for each button, to record that the action happened\n    observe({\n        if (input$xgraphsUpdateButton != 0 | input$PSCalcUpdateButton != 0) {\n            buttonvalues$lastActionX <- 'prune'\n        }\n    })\n    observe({\n        if (input$psButton != 0 | input$selVarsButton != 0) {\n            buttonvalues$lastActionX <- 'specify'\n        }\n    })\n    # and now one for the rug plots\n    buttonvalues$lastActionRug <- NULL\n    observe({\n        if (useLogit() | !useLogit()) {\n            buttonvalues$lastActionRug <- 'choosePlot'\n        }\n    })\n    observe({\n        if (!is.null(input$logitpsPlot_brush$xmin) | \n            !is.null(input$psPlot_brush$xmin) | \n            !is.null(input$logitpsPlot_brush$xmax) | \n            !is.null(input$psPlot_brush$xmax)) { \n            buttonvalues$lastActionRug <- 'brush'\n        }\n    })\n\n\n    pruneValRawList <- reactive({\n        if (is.null(varsToView())) return(NULL)\n\n        mylist <- vector(\"list\", numvarsToView())\n\n        for (i in 1:numvarsToView()) {\n            mylist[[i]]  <- input[[paste0(\"pruningChoices_\", i)]]\n        }\n        mylist\n    })\n\n    pruneValTextList <- reactive({\n        # dependencies\n        if (is.null(varsToView())) return(NULL)\n        if ((input$xgraphsUpdateButton == 0 & input$PSCalcUpdateButton == 0) | \n            identical(buttonvalues$lastActionX, 'specify'))  {\n            return(NULL)\n        }\n        \n        mylist <- vector(\"list\", numvarsToView())\n        \n        for(i in 1:numvarsToView()) {\n            myvals  <- isolate(pruneValRawList())[[i]]\n            varname <- varsToView()[i]\n            \n            # We are coding for the ones to KEEP\n            mylist[[i]] <- if (varIsContinuous()[i]) {\n                myvals_numeric <- suppressWarnings(as.numeric(\n                    unlist(strsplit(as.character(myvals), \" \"))))\n                if (length(na.omit(myvals_numeric)) == 2) {\n                    paste0(varname, \" >= \", myvals_numeric[1], \n                    \" & \", varname, \" <= \", myvals_numeric[2])\n                } else { # user entered invalid text\n                    TRUE\n                }\n            } else { # var is not continuous\n                if (is.numeric(dset.orig()[[varname]])) {\n                    paste0(varname, \" %in% c(\", paste(myvals, collapse= \",\"),\")\") \n                } else { # character var\n                    paste0(\"(\", paste(varname, \" == \", \n                        paste0(\"'\", myvals, \"'\"), collapse= \" | \"),\n                        \")\")\n                }    \n            }\n        } # next i\n        mylist\n    })    \n\n    exprToKeepAfterPruning <- reactive({\n        if (is.null(pruneValTextList())) return(NULL)\n        \n        do.call(\"paste\", list(pruneValTextList(), collapse= \" & \" ))\n    })    \n    \n    output$keepAfterPruningCopyText <- renderUI({\n        if (is.null(pruneValTextList())) return(NULL)\n\n        HTML(do.call(\"paste\", list(pruneValTextList(), collapse= \" & <br/>\" )))\n    })    \n    \n    idsToKeepAfterPruning <- reactive({\n        if (is.null(nonMissingIDs())) return(NULL)\n\n        if (is.null(exprToKeepAfterPruning())) return(nonMissingIDs())\n\n        # todo: fix syntax (do all in data.table)\n        dat <- as.data.frame(dset.orig()[nonMissingIDs()])\n        tryCatch(as.data.table(dat[with(dat, eval(parse(text= \n            exprToKeepAfterPruning()))), ])[[idvarName()]],\n            error= function(e) nonMissingIDs())\n    })    \n    \n    output$pruneTable <- renderTable({\n        if (is.null(nonMissingIDs())) return(NULL)\n\n        dat <- data.frame(addmargins(table(\n            unlist(dset.orig()[xgraphs.ids(), groupvarFactorName(), with= FALSE]), \n            dnn= groupvarname())))\n        rownames(dat) <- dat[, 1]\n        rownames(dat)[rownames(dat) == \"Sum\"] <- \"Total\"\n        names(dat)[2] <- \"n\"\n        dat[, 2, drop= FALSE]\n    }, display= c(\"s\", \"d\"))\n\n    ############################################################\n    ############################################################\n    ## Plotting \n    \n    colorScale.mod <- reactive({\n        if (is.null(nonMissingIDs())) return(NULL)\n        myColorScale[1:length(unique(dset.orig()[[groupvarFactorName()]]))]\n    })\n    \n    output$psPlot <- renderPlot({\n        # todo: change if I eliminate dset.psgraphs\n        if (is.null(dset.psgraphs())) return(NULL)\n        \n        p <- ggplot(data= dset.psgraphs(),\n            aes(x= ps)) +\n            geom_histogram(\n                alpha    = alpha1, \n                position = 'identity', \n                aes(fill= group)) +\n            scale_fill_manual(groupvarname(), values= colorScale.mod()) +\n            xlab(paste0(\"PS (n= \", nrow(dset.psgraphs()), \")\")) +\n            theme(legend.position= \"right\")\n\n        # it is very important to have just p here, not print(p)!\n        p \n    })    \n    \n    output$psPlotui <- renderUI({\n        if (is.null(dset.psgraphs())) return(NULL)\n\n        plotOutput(\"psPlot\", \n            height = 300,\n            brush  = if (useLogit() == FALSE) {\n                brushOpts(\n                    id = \"psPlot_brush\",\n                    delay = 300,\n                    delayType = \"debounce\",\n                    direction = \"x\",\n                    resetOnNew = TRUE\n                )\n            } else NULL\n        )\n    })\n    \n    output$logitpsPlot <- renderPlot({\n        if (is.null(dset.psgraphs())) return(NULL)\n\n        p <- ggplot(data= dset.psgraphs(),\n            aes(x= logit.ps)) +\n            geom_histogram(\n                alpha    = alpha1, \n                position = 'identity', \n                aes(fill= group)) +\n            scale_fill_manual(groupvarname(), values= colorScale.mod()) +\n            xlab(paste0(\"Logit PS (n= \", nrow(dset.psgraphs()), \")\")) +\n            theme(legend.position= \"none\")\n            \n        # it is very important to have just p here, not print(p)!\n        p \n    })    \n    \n    output$logitpsPlotui <- renderUI({\n        if (is.null(dset.psgraphs())) return(NULL)\n\n        plotOutput(\"logitpsPlot\", \n            height = 300,\n            brush  = if (useLogit() == TRUE) {\n                brushOpts(\n                    id = \"logitpsPlot_brush\",\n                    delay = 300,\n                    delayType = \"debounce\",\n                    direction = \"x\",\n                    resetOnNew = TRUE\n                )\n            } else NULL\n        )\n    })\n    \n\n    # modified from https://gist.github.com/wch/5436415/, with\n    # help from a SO post I forgot to get the URL for\n    # also from http://stackoverflow.com/questions/19130455/create-dynamic-number-of-input-elements-with-r-shiny\n    observe({\n        for (i in 1:numvarsToView()) {\n            # My sources say:\n            # Need local so that each item gets its own number. \n            # Without it, the value # of i in the renderPlot() \n            # will be the same across all instances, \n            # because of when the expression is evaluated.\n            local({\n                my_i <- i\n                varname <- varsToView()[my_i]\n                plotname <- paste0(\"plot\", my_i)\n                prunername <- paste0(\"pruner\", my_i)\n                inputname <- paste0(\"pruningChoices_\", my_i)\n                textCheckName <- paste0(\"textcheck\", my_i)\n     \n                # Call renderPlot for each selected variable. \n                output[[plotname]] <- renderPlot({\n                    p <- ggplot(\n                        data= dset.orig()[xgraphs.ids()],\n                        aes_string(\n                            x      = varname,\n                            fill   = groupvarFactorName(),\n                            colour = groupvarFactorName()\n                        )) +\n                        scale_fill_manual(groupvarname(), \n                            values= colorScale.mod()) +\n                        scale_colour_manual(groupvarname(), \n                            values= colorScale.mod(), \n                            guide= FALSE)\n                        xlab(paste0(varname, \n                            \" (n= \", length(xgraphs.ids()), \")\"))\n                    \n                    # Histogram or bar chart\n                    if (varIsContinuous()[my_i]) {    \n                        p <- p + geom_histogram(\n                            alpha    = alpha1, \n                            position = 'identity') \n                    } else {\n                        p <- p + geom_bar(\n                            alpha= alpha1, \n                            position= position_dodge()) #+\n                            #scale_x_discrete(breaks= mylevels,\n                            #    labels= mylevels)\n                    }    \n                    \n                    # legend\n                    if (my_i == 1) {\n                        p <- p + theme(legend.position= \"top\")\n                    } else {\n                        p <- p + theme(legend.position= \"none\")\n                    }  \n                    \n                    # add the rug plots\n                    if (!is.null(idsForRug())) { \n                        p <- p + geom_rug(\n                            data= dset.orig()[idsForRug()],  # keep aes() from above\n                            sides= \"b\") \n                    }    \n                    # just p here!  not print(p)!\n                    p\n                }) # end renderPlot\n\n                # Create input function for each variable\n                output[[prunername]] <- renderUI({\n                    if (varIsContinuous()[my_i]) {\n                        textInput(\n                            inputname, \n                            paste0(varname, \": Keep only observations in this range (inclusive).\",\n                                \" Separate the min and max by a space:\"),\n                            # make min & max slightly more extreme than rounded min and max in data, so that we don't get accidental pruning using the default values\n                            value= paste(\n                                floor(10^xdig() *   min(unlist(dset.orig()[nonMissingIDs(), eval(varname), with= FALSE]))) / 10^xdig(),\n                                ceiling(10^xdig() * max(unlist(dset.orig()[nonMissingIDs(), eval(varname), with= FALSE]))) / 10^xdig(),\n                                collapse= \", \")\n                        )\n                    } else { # we have categorical var, either factor or char\n                        checkboxGroupInput(\n                            inputname, \n                            paste0(varname, ': Keep only observations with the following value(s):'),\n                            # as.character corrects the printing of factor levels\n                            choices=  as.character(sort(unique(unlist(dset.orig()[nonMissingIDs(), eval(varname), with= FALSE])))),\n                            selected= as.character(sort(unique(unlist(dset.orig()[nonMissingIDs(), eval(varname), with= FALSE]))))\n                        )\n                    }\n                 }) # end renderUI\n\n                # Check the textInput for each variable\n                output[[textCheckName]] <- renderText({\n                    if (is.null(pruneValTextList())) return(NULL)\n                    if (varIsContinuous()[my_i]) {\n                        if (pruneValTextList()[[my_i]] == TRUE) {\n                            \"Please type min and max, separated by one space.\"\n                        } else { # no problem\n                            return(NULL)\n                        }\n                    } else { # categorical var, nothing to check\n                        return(NULL)\n                    }\n                 }) # end renderText\n            }) # end local\n        } # end for\n    }) # end observe    \n    \n    # Now put them all together\n    output$univariatePlotsAndInputs <- renderUI({\n        if (is.null(varsToView())) return(NULL)\n        \n        plot_and_input_list <- vector(\"list\", numvarsToView())\n        for(i in 1:numvarsToView()) {\n            plotname <- paste0(\"plot\", i)\n            prunername <- paste0(\"pruner\", i)\n            textcheckname <- paste0(\"textcheck\", i)\n            \n            plot_and_input_list[[i]] <-\n                fluidRow(\n                    column(6, \n                        plotOutput(plotname, \n                            # first plot taller to accomodate legend\n                            height = ifelse(i == 1, 320, 280), \n                            width  = 400#,\n                        ) # end plotOutput   \n                    ), # end column\n                    column(6, \n                        uiOutput(prunername),\n                        uiOutput(textcheckname)\n                    ) # end column\n                )# end fluidRow\n        } \n        plot_and_input_list\n    })\n \n    \n    ############################################################\n    ############################################################\n    # Session Information\n    output$sessionInf <- renderPrint({\n        si <- sessionInfo() \n        si$loadedOnly <- NULL\n        print(si, locale=FALSE)\n    })\n    \n    # server.R code for display\n    output$serverCode <- renderPrint({\n        cat(readLines(con= \"server.R\"), sep= \"\\n\")\n    })\n\n    # ui.R code for display\n    output$uiCode <- renderPrint({\n        cat(readLines(con= \"ui.R\"), sep= \"\\n\")\n    })\n}) # end shiny server\n    \n",
    "created" : 1458925096626.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2340952540",
    "id" : "B5630102",
    "lastKnownWriteTime" : 1458925131,
    "last_content_update" : 1458925131198,
    "path" : "~/Documents/VisualPruner/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}